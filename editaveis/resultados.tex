\chapter{Características do SMI-UnB}

\section{Tecnologias Escolhidas}
Definiu-se a utilização do \textit{framework} Django \cite{django_project} como estrutura base do SMI-UnB, visto que o sistema consistiria em uma aplicação \textit{web} e que o período para desenvolvimento seria curto.

O banco de dados PostgreSQL foi escolhido como um serviço necessário para SMI-UnB, visto que ele seria capaz de atender o alto volume de informações armazenadas. Além disso, pelo Django e o PostgreSQL se tratarem de softwares livres, suas escolhas foram mais adequadas ao projeto, que por sua vez, também é livre.

    \subsection{Django}
    O Django é um \textit{framework} para desenvolvimento \textit{web} implementado na linguagem Python\footnote{\url{https://www.python.org/}}. Sua arquitetura se inspira no modelo tradicional MVC (\textit{Model} \textit{View} \textit{Controller}), porém, com algumas especificidades. A comunidade \textit{Django} adota o acrônimo MTV (\textit{Model} \textit{Template} \textit{View}), onde os papéis de \textit{model}, \textit{view} e \textit{controller} são redefinidos como:
    \begin{itemize}
        \item \textit{Model}: corresponde à \textit{model} do MVC tradicional e representa as classes que popularão as tabelas do banco de dados. O \textit{Django} possui um \textit{Object-Relational Mapping} (ORM), para realizar a manipulação dessas tabelas, não sendo necessária a escrita de consultas em SQL para a persistência das informações;
        \item \textit{Template}: corresponde aproximadamente à \textit{view} do MVC tradicional e descreve como as informações serão apresentadas para o usuário;
        \item \textit{View}: representada por uma função \textit{callback} referente a uma classe de URLs, descrevendo quais informações serão apresentadas e como elas serão enviadas para o \textit{template}. Alguns autores defendem que a view corresponde ao \textit{controller} do MVC tradicional, mas para os próprios desenvolvedores do \textit{Django}, a \textit{view} deve ser minimalista e boa parte do papel do \textit{controller} deve ser implementado nas próprias classes dos modelos.
    \end{itemize}

    Na nomenclatura do \textit{Django}, um conjunto de funcionalidades pode ser agrupado em uma aplicação, chamada de \textit{app}. Cada aplicação possui suas próprias \textit{models}, \textit{views} e \textit{templates}.

    A Figura \ref{django-arq} mostra a arquitetura do \textit{Django}, apresentando as camadas do MTV durante a comunicação com o navegador até o acesso ao banco de dados. O \textit{URL dispatcher} identifica endereços requisitados pelo usuário e realiza o redirecionamento da requisição para a aplicação correta. A coordenação de requisições entre o \textit{URL dispatcher} e a \textit{view} e da \textit{view} até o \textit{template} é feita pelos chamados \textit{Middlewares}. Os \textit{Middlewares} realizam a persistência de informações entre as diferentes camadas.

    \begin{figure}[h]
        \centering
        \includegraphics[keepaspectratio=true,scale=0.5]{figuras/django-arquitetura.eps}
        \caption{Arquitetura MTV \textit{Django}.}
        \label{django-arq}
    \end{figure}

\section{Protocolos Utilizados}
Antes de começar o desenvolvimento, foi necessário realizar um profundo estudo sobre o equipamento para medição de dados de energia, comumente chamado de transdutor, visto que esse já havia sido pré-designado para utilização, devido a contratos realizados anteriormente pela Universidade de Brasília.

O equipamento em questão foi o TR 4020, Figura \ref{tr4020}, disponibilizado pela empresa Embrasul \cite{embrasul}. Segundo seu manual, possui frequência de amostragem a cada 50ms, comunica-se utilizando o protocolo de comunicação Modbus, no modo RTU, com velocidades de 10M/100Mbps em sistemas Ethernet, utilizando o protocolo UDP como transporte. No datagrama UDP, no campo de dados, o protocolo ModBUs-RTU é encapsulado, sendo que a porta de comunicação padrão é a 1001. O endereço ModBus dos equipamentos por padrão é 1, onde a diferenciação entre equipamentos se dá pelo número de IP.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.5]{figuras/tr4020.eps}
    \caption{Transdutor TR4020. Fonte: \cite{embrasul}}
    \label{tr4020}
\end{figure}

    \subsection{\textit{Modbus-RTU}}

    \textit{Modbus} \cite{modbus} é um protocolo serial utilizado para transmitir informações entre dispositivos eletrônicos. Suas mensagens utilizam a arquitetura de mestre-escravo, como mostra a Figura \ref{mestre_escravo}. Nesta arquitetura, o papel de mestre é designado ao dispositivo que envia as requisições e de escravo ao que responde passivamente a elas.

    \begin{figure}[!htb]
        \centering
        \includegraphics[keepaspectratio=true,scale=0.8]{figuras/mestre_escravo.eps}
        \caption{Comunicação Mestre-Escravo \textit{Modbus}. Fonte: \cite{modbus}}
        \label{mestre_escravo}
    \end{figure}

    Quando controladores são configurados para se comunicarem em uma rede Modbus, usando o modo \textit{Remote Terminal Unit} (RTU), cada \textit{byte} contem duplas hexadecimais de 4 \textit{bits}. A maior vantagem em se utilizar esse modo é que sua grande densidade de caracteres permite uma maior taxa de transferência comparado ao modo ASCII, em uma mesma taxa de transmissão \cite{modbus}.

    Uma mensagem em Modbus RTU possui 16 \textit{bytes} e é definida da seguinte maneira:
    \begin{itemize}
        \item Identificador do Aparelho: 2 \textit{bytes};
        \item Código de Função: 2 \textit{bytes}, define qual tipo de operação o equipamento irá realizar;
        \item Campo de Dados: 8 \textit{bytes}, sendo 4 \textit{bytes} para indicar o endereço do primeiro registrador requisitado e 4 \textit{bytes} para indicar a quantidade de registradores que serão lidos;
        \item \textit{Cyclic Redundancy Check} (CRC): 4 \textit{bytes} para verificação de erros.
    \end{itemize}

    A resposta do escravo possui a seguinte estrutura:

    \begin{itemize}
        \item Identificador do Aparelho: 2 \textit{bytes};
        \item Código de Função: 2 \textit{bytes}, define qual tipo de operação o equipamento irá realizar;
        \item Tamanho do \textit{Payload}: 2 \textit{bytes}, define o tamanho do campo de dados em \textit{bytes};
        \item Campo de Dados: possui tamanho variável, de acordo com o valor do campo anterior;
        \item \textit{Cyclic Redundancy Check} (CRC): 4 \textit{bytes} para verificação de erros.
    \end{itemize}

    \subsubsection{Leitura utilizando equipamento TR4020}
    Para ler e compor um valor em ponto flutuante \cite{ieee754} se deve realizar a leitura de 2 registros Modbus (16 \textit{bits} cada). Por exemplo, para ler o valor de tensão na fase A (endereços 68 e 69), escreve-se na comunicação a sequência de \textit{bytes}, conforme o Algoritmo \ref{request_tr4020}.

    \begin{python}[caption={Requisição para leitura de tensão na fase A, utilizando TR4020.}, captionpos=b, label={request_tr4020}]
    01h # Identificador do aparelho
    03h # Codigo de funcao (Leitura)
    00h # Primeiro byte do endereco 68
    44h # Segundo byte do Endereco 68
    00h # Bytes a serem lidos
    02h # Bytes a serem lidos (total: 2 bytes)
    84h # CRC
    1Eh # CRC
    \end{python}

    Tem-se como resultado, por exemplo, a responsta contida no Algoritmo \ref{response_tr4020}.

    \begin{python}[caption={Resposta para leitura de tensão na fase A, utilizando TR4020.}, captionpos=b, label={response_tr4020}]
    01h # Identificador do Aparelho
    03h # Codigo de funcao (Leitura)
    04h # Tamanho do payload (4 bytes)
    38h # Primeiro byte do valor para tensao na fase A
    88h # Segundo byte do valor para tensao na fase A
    43h # Terceiro byte do valor para tensao na fase A
    59h # Quarto byte do valor para tensao na fase A
    C7h # CRC
    87h # CRC
    \end{python}

    Utiliza-se os conceitos de uma arquitetura \textit{little endian} \cite{tanenbaum_1998} para organizar os \textit{bytes} do valor para tensão na fase A, Algoritmo \ref{little_endian} . Essa arquitetura define que a organização dos \textit{bytes} de uma palavra deve começar dos \textit{bits} menos significativos para os mais significativos.

    \begin{python}[caption={Organização do valor para tensão na fase A, utilizando uma arquitetura \textit{little endian}.}, captionpos=b, label={little_endian}]
    88h # Antigo segundo byte
    38h # Antigo primeiro byte
    59h # Antigo quarto byte
    43h # Antigo terceiro byte
    \end{python}

    O valor 217.220 é obtido para tensão na fase A após a leitura.

    \subsection{UDP}
    O protocolo \textit{User Datagram Protocol} (UDP) é um protocolo da camada de transporte, não orientado a conexões. Seu cabeçalho, Figura \ref{udp_header}, possui 8 \textit{bytes}, seguido de uma carga útil. As portas apresentadas no cabeçalho representam as máquinas de origem e destino \cite{tanenbaum_2002}.

    \begin{figure}[!htpb]
        \centering
        \includegraphics[keepaspectratio=true,scale=0.8]{figuras/udp_header.eps}
        \caption{Cabeçalho do UDP. Fonte: \cite{tanenbaum_2002}}
        \label{udp_header}
    \end{figure}

    Para Tanembaum, a camada de transporte é o núcleo de toda a hierarquia de protocolos. Sua função é promover uma transferência de dados confiável e econômica entre a máquina de origem e a máquina de destino, independente das redes físicas em uso no momento.

    Nas redes de acesso empresarial, uma rede de área local (LAN) é usada para conectar um sistema final a um roteador de borda. Existem muitos tipos diferentes de tecnologias LAN. No entanto, a \textit{Ethernet} é a tecnologia de acesso mais prevalente nas redes corporativas. A \textit{Ethernet} opera 10 Mbps ou 100Mbps e utiliza cabos par trançado para conectar uma série de sistemas finais uns com os outros e com um roteador de borda. O roteador de borda é responsável por rotear pacotes que tenham destinos fora dessa LAN. A \textit{Ethernet} usa um meio compartilhado para que os usuários finais compartilhem a taxa de transmissão da LAN \cite{kurose_2002}.

    O protocolo de camada de rede da Internet se chama ``Protocolo da Internet'', ou IP. O IP fornece comunicação lógica entre hosts, possuindo um modelo de entrega de melhor esforço. Isso significa que o IP realiza seu ``melhor esforço'' para fornecer segmentos entre hosts comunicantes, mas não oferece garantias. Em particular, não garante a entrega do segmento, não garante a entrega ordenada de segmentos e garante a integridade dos dados nos segmentos \cite{kurose_2002}.

\section{Armazenamento das Informações}
Definiu-se que os câmpus da UnB seriam divididos por região administrativa, cada campus teria um conjunto de edifícios, cada edifício poderia possuir diversos transdutores e os transdutores teriam diversas medições. Para que isso fosse possível, criaram-se os \textit{apps} \textit{campuses}, \textit{buildings} e \textit{transductor}.

A ferramenta utilizada para realizar os diagramas de classes dos \textit{apps} do SMI-UnB foi a StarUML\footnote{\url{http://staruml.io/}}. Além disso, não foram expressas nos diagramas as classes referentes as \textit{views} e \textit{forms}, objetivando uma menor poluição visual.

No \textit{app} \textit{campuses}, Figura \ref{campuses}, são definidos os modelos para uma região administrativa e os câmpus em si.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.8]{figuras/campuses.eps}
    \caption{Diagrama de Classes para \textit{app} \textit{campuses}.}
    \label{campuses}
\end{figure}

Seguindo o mesmo princípio, o \textit{app} \textit{buildings}, Figura \ref{buildings}, define um modelo para os edifícios e possui um \textit{manager}, buscando auxiliar a manipulação de seus \textit{querysets}. Um \textit{queryset} representa uma coleção de objetos do banco de dados \cite{django_project}.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.8]{figuras/buildings.eps}
    \caption{Diagrama de Classes para \textit{app} \textit{buildings}.}
    \label{buildings}
\end{figure}

As medições de energia iriam seguir o esquema de um sistema trifásico, onde suas fases foram representadas como A, B e C. As grandezas energéticas definidas para serem coletadas foram:

\begin{itemize}
    \item Tensão;
    \item Corrente;
    \item Potência Ativa;
    \item Potência Reativa;
    \item Potência Aparente.
\end{itemize}

Os transdutores e suas medições são definidos no \textit{app} \textit{transductor}, Figura \ref{transductor}. Uma das peculariedas presente nos transdutores é a necessidade de um modelo de transdutor. Esses modelos, definidos pela classe \textit{TransductorModel}, possuem toda a informação necessária para que seja possível realizar a coleta de dados, definindo o endereço e o tipo (\textit{int} ou \textit{float}) dos registradores que serão lidos, além dos protocolos seriais e de transporte utilizados.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.7]{figuras/transductor.eps}
    \caption{Diagrama de Classes para \textit{app} \textit{transductor}.}
    \label{transductor}
\end{figure}

As classes \textit{Transductor} e \textit{Measurements} são \textit{Polymorphic Models}\footnote{\url{https://django-polymorphic.readthedocs.io/en/stable/}} e possuem alguns métodos base. Com essas classes é possível extrair com mais facilidade e rapidez todas as suas classes filhas, que no caso seriam as representações dos recursos monitorados pela UnB. As especializações criadas foram referentes aos transdutores de energia e medições de energia, representados pelas classes \textit{EnergyTransductor} e \textit{Energymeasurements}. Além disso, existe uma classe auxiliar, chamada \textit{EnergyOperations}, responsável por realizar cálculos matemáticos com os dados de energia coletados.

\section{Coleta de dados}
Definiu-se que existirão dois tipos de servidores para ser possível realizar a coleta de dados inter-campi: mestre e escravo. O servidor mestre seria a representação da administração central e os escravos seriam prédios, espalhados pelos câmpus da UnB, que realizariam a coleta de dados de seus transdutores, presentes na sua mesma rede.

O tempo para coleta das informações foi definido da seguinte maneira:

\begin{itemize}
    \item A cada 1 hora, o servidor mestre seria responsável por realizar uma sincronia com todas as medições realizadas pelos escravos;
    \item A cada 1 minuto, os servidores escravos seriam responsáveis por realizarem suas coletas de dados.
\end{itemize}

\subsection{Servidor Escravo}
A coleta de dados, realizada por um prédio (servidor escravo), é feita com o auxílio do app \textit{data\_reader}, Figura \ref{data_reader}.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.7]{figuras/data_reader.eps}
    \caption{Diagrama de Classes para \textit{app} \textit{data\_reader}.}
    \label{data_reader}
\end{figure}

A classe \textit{SerialProtocol} e \textit{TransportProtocol} são abstratas e possuem alguns métodos base, para que possa ser possível criar diferentes tipos de especializações, conforme a aplicação necessite. As duas inicialmente criadas, foram referentes aos protocolos Modbus-RTU e UDP.

A coleta de dados para cada prédio, com base no equipamento TR4020, é ilustrada pela Figura \ref{process_1}. Foi utilizada a ferramenta Bizagi\footnote{\url{https://www.bizagi.com/}} para a realização da modelagem.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=1.0]{figuras/process_1.eps}
    \caption{Coleta de dados energéticos utilizando TR4020.}
    \label{process_1}
\end{figure}

Inicialmente, a classe \textit{DataCollector} identifica todos os transdutores que estão no prédio e cria uma \textit{thread} para cada um, objetivando paralelismo na coleta de dados. Segundo Tanembaum \cite{tanenbaum_2007}, as \textit{threads} são entidades escalonadas para a execução sobre a CPU, permitindo que múltiplas execuções ocorram no mesmo ambiente de um processo, com um grande grau de independência uma da outra.

Em cada \textit{thread} é identificado o modelo TR4020 para o transdutor, o qual possui as informações sobre os protocolos Modbus-RTU e UDP. A classe \textit{ModbusRTU} prepara todas as mensagens que deverão ser lidas pelo equipamento, uma para cada grandeza energética e para cada fase. As mensagens seriais criadas são recebidas pela classe \textit{UdpProtocol}, que irá tentar realizar a comunicação com o aparelho. Os pacotes são enviados e recebidos, um por um, até que todos sejam recebidos corretamente. Com os pacotes recebidos, são extraídas suas cargas úteis, que basicamente correspondem às medições de cada grandeza, logo após, elas são lidas, utilizando a classe \textit{ModbusRTU}. Por fim, a classe \textit{DataCollector} recebe as medições e as salva.

A coleta temporizada, a cada 1 minuto, das medições energéticas realizadas pelos prédios utiliza a ferramenta \textit{cron} \cite{paul_cron}, presente em sistemas UNIX. O \textit{cron} é um \textit{daemon} para executar comandos de agendamento. Um \textit{daemon} é um programa executado em segundo plano e visa estar sempre em execução, caso seja iniciado. Além disso, o \textit{cron} utiliza o \textit{crontab} para manter os arquivos, que possuem instruções a serem executadas periodicamente, de cada usuário. Um arquivo mantido pelo \textit{crontab} deve seguir a estrutura do Algoritmo \ref{crontab}.

\begin{python}[caption={Estrutura de um arquivo mantido pelo \textit{crontab}.}, captionpos=b, label={crontab}]
minuto hora dia_mes mes dia_semana comando_para_execucao
# Linha em banco para deixar cron valido
\end{python}

Adicionou-se um novo comando para a aplicação, chamado \textit{runcrons}. Esse comando é definido pela ferramenta django-cron\footnote{\url{http://django-cron.readthedocs.io/en/latest/}} e basicamente executa um código que possua como base a classe \textit{CronJobBase}. Esse código, após ser executado, é bloqueado até que o tempo de espera para outra execução seja atingido, como uma espécie de cronômetro.

Criou-se a classe \textit{DataCollectCronJob}, Algoritmo \ref{data_collect}, objetivando invocar o \textit{DataCollector} para realizar a coleta de dados. O arquivo mantido pelo crontab para realizar a coleta, periodicamente a cada 1 minuto, foi definido conforme o Algoritmo \ref{cron_slave}.

\begin{python}[caption={Classe \textit{DataCollectCronJob}.}, captionpos=b, label={data_collect}]
class DataCollectCronJob(CronJobBase):
    RUN_EVERY_MINS = 0
    schedule = Schedule(run_every_mins=RUN_EVERY_MINS)
    code = 'smi_unb.data_reader.cronjob.DataCollectCronJob'

    def do(self):
        data_collector = DataCollector()
        data_collector.perform_all_data_collection()
\end{python}

\begin{python}[caption={\textit{Cron} para execução da coleta dos dados de energia.}, captionpos=b, label={cron_slave}]
* * * * * python3 /SMI-UnB/manage.py runcrons \
smi_unb.data_reader.cronjob.DataCollectCronJob
# Necessary line at end of file to make cron valid
\end{python}

\subsection{Servidor Mestre}
O servidor mestre não realiza nenhuma coleta de dados, sendo esse responsável por realizar uma sincronização com os dados coletados pelos servidores escravos por meio de uma API \textit{web}.

\textit{Application Programming Interface} (API) é um conjunto de requisitos que regem como um aplicativo pode conversar com outro. As APIs realizam isso expondo algumas das funções internas de um programa para o mundo exterior de forma limitada, possibilitando que os aplicativos compartilhem dados e tomem ações em nome do outro, sem exigir que os desenvolvedores compartilhem todo o código do software \cite{brian_api}.

Quando usado no contexto do desenvolvimento \textit{web}, uma API é tipicamente definida como um conjunto de requisições do protocolo HTTP, juntamente com uma definição da estrutura de mensagens de resposta, geralmente utilizando as linguagens \textit{Extensible Markup Language} (XML) ou \textit{JavaScript Object Notation} (JSON) \cite{benslimane_2008}.

O \textit{Hypertext Transfer Protocol} (HTTP), é um protocolo \textit{web} presente na camada de aplicação do modelo OSI e é implementado por dois programas: um cliente e outro servidor. Os programas cliente e servidor conversam entre si, trocando mensagens HTTP, sendo que o protocolo define como o cliente (por exemplo, um navegador) solicitará páginas \textit{web} de um servidor (por exemplo, o Django) e como o servidor irá transferir essas páginas para o cliente \cite{kurose_2002}.

A API utilizada no projeto baseou-se no Django REST Framework \cite{django_rest}. O \textit{Representational State Transfer} (REST) \cite{fielding_2000} é um estilo arquitetural para projetar sistemas distribuídos e apresenta as seguintes características:

\begin{itemize}
    \item Estado e funcionalidade são divididos em recursos distribuídos;
    \item Todo recurso é exclusivamente endereçável, usando um conjunto uniforme e mínimo de comandos;
    \item O protocolo é cliente/servidor, sem estado, em camadas e suporta armazenamento em \textit{cache}.
\end{itemize}

O Django REST Framework utiliza alguns métodos HTTP para mapear as operações CRUD (criar, resgatar, atualizar e deletar) nas requisições HTTP, sendo estes:

\begin{itemize}
    \item GET: recuperar informações de uma entidade;
    \item POST: criar ou atualizar uma entidade;
    \item PUT: criar ou atualizar uma entidade. O método PUT é idempotente, ou seja, se uma operação for realizada duas vezes sobre o mesmo objetivo, não haverá efeito;
    \item PATCH: modificar parcialmente uma entidade;
    \item DELETE: deletar uma entidade.
\end{itemize}

O conceito de \textit{endpoints} é utilizado pelo Django REST Framework, objetivando a interação com a API do lado do servidor, pois especificam onde os recursos podem ser acessados. Uma das classes padrão utilizada no projeto foi a \textit{ModelViewSet}. Além disso, o Django REST Framework utiliza serializadores. Os serializadores permitem que dados complexos, como \textit{querysets} e instâncias de modelos, sejam convertidos em tipos de dados Python nativos que podem ser facilmente processados em JSON, XML ou outros tipos de conteúdo. Os serializadores também fornecem desserialização, permitindo que os dados analisados sejam convertidos novamente em tipos complexos, após realizada uma validação dos dados recebidos \cite{django_rest}.

A sincronia de dados é realizada pela classe \textit{EnergyMeasurementSynchronizer}, presente no \textit{app} \textit{api}, Figura \ref{api}. Em linhas gerais, essa classe realiza duas requisições HTTP para cada servidor escravo. Na primeira requisição são consumidas as medições de energia mais recentes de cada transdutor, via API. Com as medições resgatadas, atualiza-se o horário da última coleta de dados de cada transdutor, no servidor mestre. Após atualizados os horários no mestre, realiza-se a segunda requisição, que atualiza o horário de todos os transdutores presentes no escravo.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.55]{figuras/api.eps}
    \caption{Diagrama de Classes para \textit{app} \textit{api}.}
    \label{api}
\end{figure}

O \textit{crontab} para se realizar a sincronia das medições, a cada 1 hora, é expresso pelo Algoritmo \ref{cron_master} e utiliza a classe \textit{MeasurementsSyncCronJob}, Algoritmo \ref{measu_sync}.

A base da API foi realizada com sucesso, para que no futuro haja apenas aprimoramentos. Ressalta-se que essa foi um protótipo, não possuindo nenhum tipo de autenticação e não sendo hiperlincada, conforme recomendado pelo Django REST Framework.

\begin{python}[caption={\textit{Cron} para execução da sincronia dos dados de energia.}, captionpos=b, label={cron_master}]
0 * * * * python3 /SMI-UnB/manage.py runcrons \
smi_unb.api.cronjob.MeasurementsSyncCronJob
# Necessary line at end of file to make cron valid
\end{python}

\begin{python}[caption={Classe MeasurementsSyncCronJob.}, captionpos=b, label={measu_sync}]
class MeasurementsSyncCronJob(CronJobBase):
    RUN_EVERY_MINS = 59
    schedule = Schedule(run_every_mins=RUN_EVERY_MINS)
    code = 'smi_unb.api.cronjob.MeasurementsSyncCronJob'

    def do(self):
        e_synchronizer = EnergyMeasurementSynchronizer()
        e_synchronizer.perform_all_measurements_sync()
\end{python}

\section{Segurança}
Realizou-se um sistema de \textit{login} por meio de e-mail, para facilitar os usuários a se autenticarem no sistema. O Django já possui um módulo de autenticação bem definido, que realiza tanto a autenticação quanto a autorização de um usuário. Como esse módulo realizava \textit{login} por meio do nome de usuário, algumas mudanças foram implementadas para ser possível o \textit{login} por meio de e-mail. Para isso, criou-se o \textit{app} \textit{authentication}, Figura \ref{authentication}, o qual define a classe \textit{EmailBackend}, que por sua vez realiza a autenticação por e-mail.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.8]{figuras/authentication.eps}
    \caption{\textit{App} authentication}
    \label{authentication}
\end{figure}

Ressalta-se que o Django realiza a criptografia das senhas registradas no banco de dados automaticamente, utilizando como base a \textit{secret\_key} do projeto. Por esse motivo, essa \textit{secret\_key} é gerada randomicamente, conforme o Algoritmo \ref{secret_key}.

\begin{python}[caption={Criação automática da \textit{secret\_key} do projeto.}, captionpos=b,label={secret_key}]
try:
    with open(secrete_key_path, 'r') as F:
        SECRET_KEY = F.read()
except FileNotFoundError:
    print('Creating a new SECRET_KEY at security/secret_key.dat')

    # Create directory, if it does not exist
    if not os.path.exists(security_path):
        os.mkdir(security_path)

    chars = ''.join(
        [string.ascii_letters, string.digits, string.punctuation]
    )
    SECRET_KEY = ''.join([choice(chars) for i in range(50)])

    with open(secrete_key_path, 'w') as F:
        SECRET_KEY = F.write(SECRET_KEY)
\end{python}

Os transdutores e prédios presentes no sistema não podem ser excluídos, tendo em vista a importância de se deixar registrado suas medições realizadas. Para isso acontecer, alguns botões de habilitar e desabilitar foram adicionados à aplicação e um atributo referente a ativo foi adicionado aos seus modelos.

O servidor mestre é responsável por realizar todo o registro/edição de transdutores e prédios. Assim, sempre que se tenta realizar uma operação desse tipo, o mestre realiza uma verificação, a nível de formulário, com o escravo, Algoritmo \ref{energy_form}. Essa verificação é feita por meio de uma requisição HTTP, utilizando o método GET. Caso o código de resposta recebido seja válido, o mestre tenta realizar uma sincronização com escravo pela API, utilizando a classe \textit{SyncManager}, Algoritmo \ref{build_sync}. Ressalta-se que esta solução ainda deve ser aperfeiçoada, buscando aceitar requisições mais seguras, por meio do protocolo HTTPS.

\begin{python}[caption={Corpo do método \textit{is\_valid}, classe \textit{EnergyForm}.}, captionpos=b, label={energy_form}]
class EnergyForm(forms.ModelForm):
    ...

    def is_valid(self):
        ...

        url = 'http://' + self.instance.building.server_ip_address
        try:
            request = requests.get(url, timeout=3)
        except:
            self.add_error(
                None,
                _('Unable to communicate with building server.')
            )
            return False
\end{python}

\begin{python}[caption={Sincronização realizada durante a criação de um prédio.}, captionpos=b, label={build_sync}]
def new_building(request, campus_string):
    ...

    building.synchronized = SyncManager.sync_building(
        building, new=True)

    building.save()

    ...
\end{python}

Definiu-se, inicialmente, duas permissões para os usuários: gerência de prédios e de transdutores. Cada uma dessas fornece ao usuário os direitos de incluir, modificar e habilitar/desabilitar. A gerência de usuários e definição das permissões são realizadas pelo \textit{app} \textit{users}, Figura \ref{app_users}.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.8]{figuras/app_users.eps}
    \caption{Diagrama de Classes para \textit{App} \textit{users}.}
    \label{app_users}
\end{figure}

As permissões dos usuários são definidas pela classe \textit{UserPermissions}, Algoritmo \ref{user_perm}.

\begin{python}[caption={Permissões presentes na classe \textit{UserPermissions}.}, captionpos=b,label={user_perm}]
class UserPermissions(models.Model):
    ...

    class Meta:
        permissions = (
            ("manager_buildings", "Manager Buildings"),
            ("manager_transductors", "Manager Transductors"),
        )
\end{python}

\section{Gerência de Configuração}

\subsection{Docker}
Criaram-se duas configurações para os ambientes referentes ao mestre e escravo, onde suas diferenciações baseavam-se no \textit{crontab} que seria executado em cada um. Para realizar essas configurações, utilizou-se a ferramenta Docker Compose, tornando mais fácil a definição e execução de múltiplos contêiners, com uma possibilidade de ligação entre eles. Os serviços definidos para a aplicação foram:

\begin{itemize}
    \item nginx: fornecimento dos arquivos estáticos;
    \item web: fornecimento da aplicação em Django;
    \item postgres: armazenamento das informações;
    \item redis: \textit{cache} da aplicação;
    \item data: armazenamento do banco de dados.
\end{itemize}

A configuração para o servidor mestre é representada pelo Algoritmo \ref{compose_docker}.

\begin{python}[caption={Serviços providos pelo Docker Compose.}, captionpos=b, label={compose_docker}]
version: '2'
services:
  nginx:
    restart: always
    build: ./docker/nginx/
    ports:
      - "80:80"
    volumes:
      - ./docker/nginx/collect/static/:/var/www/static/
    volumes_from:
      - web
    links:
      - web:web

  web:
    build:
      context: .
      dockerfile: ./docker/Dockerfile.master
    expose:
      - "8000"
    links:
      - postgres:postgres
      - redis:redis
    env_file: ./docker/env
    volumes:
      - ./src/:/app/src/

  postgres:
    restart: always
    image: postgres:latest
    volumes_from:
      - data
    volumes:
      - ./docker/postgres/docker-entrypoint-initdb.d: \
         /docker-entrypoint-initdb.d
    env_file:
      - ./docker/env
    expose:
      - "5432"

  redis:
    restart: always
    image: redis:latest
    expose:
      - "6379"

  data:
    restart: always
    image: alpine
    volumes:
      - /var/lib/postgresql
    command: "true"
\end{python}

O serviço nginx utiliza um servidor nginx\footnote{\url{https://nginx.org/en}} para lidar primeiramente com requisições externas e fornecer os arquivos estáticos da aplicação. O nginx consiste em um servidor HTTP e \textit{proxy} reverso. Servidores \textit{proxy} reverso utilizam um servidor \textit{proxy} para atuar como um intermediadores entre uma requisição realizada por um cliente e o servidor que a atenderá. Um servidor \textit{proxy} é uma entidade de rede que satisfaz solicitações HTTP em nome de um cliente, possuindo seu próprio armazenamento em disco e mantendo cópias de objetos recentemente solicitados \cite{kurose_2002}.

Requisições que precisam ser geradas dinamicamente são tratadas pelo serviço \textit{web}, que são enviadas para um servidor Gunicorn\footnote{\url{http://gunicorn.org/}}. O Gunicorn é um servidor Python \textit{Web Server Gateway Interface} (WSGI) HTTP. O WSGI é uma especificação para uma interface simples e universal entre servidores \textit{web} e aplicações \textit{web} ou \textit{frameworks} para a linguagem de programação Python \cite{pep_333}.

Quando o serviço \textit{web} é iniciado, executa-se um \textit{script}, Algoritmo \ref{script_start}, responsável por criar um arquivo contendo as variáveis de ambiente, popular o banco de dados com os câmpus da UnB e os modelos de transdutor base, inicializar o \textit{daemon} \textit{cron} e o servidor Gunicorn.

\begin{python}[caption={\textit{Script} \textit{start.sh}.}, captionpos=b, label={script_start}]
#!/bin/bash

# Creating file with environment variables to use in crontab
env | sed 's/^\(.*\)$/ \1/g' > /root/env

# Populating database and initializing cron and gunicorn
python3 manage.py makemigrations && \
python3 manage.py migrate && \
python3 manage.py loaddata src/smi_unb/fixtures/initial_data.json && \
cron && \
gunicorn smi_unb.wsgi -b 0.0.0.0:8000
\end{python}

A criação do arquivo contendo as variáveis de ambiente é necessária, pois o \textit{crontab} de um contêiner não possui acesso a elas. Os \textit{crontabs} dos servidores mestres e escravo realizam uma exportação das variáveis antes de executarem seus devidos comandos. O Algoritmo \ref{crontab_master} ilustra o \textit{crontab} do servidor mestre.

\begin{python}[caption={\textit{Crontab} do servidor mestre.}, captionpos=b, label={crontab_master}]
0 * * * * export $(cat /root/env | xargs) && \
python3 /app/manage.py runcrons \
smi_unb.api.cronjob.MeasurementsSyncCronJob
# Necessary line at end of file to make cron valid
\end{python}

O serviço \textit{postgres} utiliza uma imagen banco de dados PostgreSQL para realizar o armazenamento das informações.

Para acelerar as requisições de páginas \textit{web} do SMI-UnB, utilizou-se o serviço \textit{redis}, responsável por executar um servidor Redis\footnote{\url{https://redis.io/}}. O \textit{Cache} é um componente de \textit{hardware} ou software que armazena dados, objetivando uma maior rapidez para pedidos futuros. Os dados armazenados em um \textit{cache} podem ser o resultado de uma computação executada anteriormente ou da duplicação de dados presentes em um outro lugar \cite{hennessy_2011}.

O serviço \textit{data} foi utilizado para gerenciar a persistência de dados, objetivando não arriscar qualquer exclusão acidental durante, por exemplo, uma atualização no contêiner do PostgreSQL.

Criou-se um \textit{script}, Algoritmo \ref{script_postgres}, responsável por criar um arquivo contendo as variáveis de ambiente referentes ao banco de dados.

\begin{python}[caption={\textit{Script} \textit{db\_initial\_data.sh}.}, captionpos=b, label={script_postgres}]
#!/bin/bash
echo "Collecting data to create the database..."

read -p "Enter the database name: " db_name

read -p "Enter the database user: " db_user

while true; do
    read -s -p "Enter the database password: " db_pass
    echo
    read -s -p "Confirm the database password: " db_pass_confirm
    [ "$db_pass" = "$db_pass_confirm" ] && break
    echo -e "\nPasswords don't match. Please try again...\n"
done

file="./docker/env"

if [ -f "$file" ]
then
    rm "$file"
fi

printf "DB_NAME=$db_name\nDB_USER=$db_user\nDB_PASS=$db_pass
        \nDB_SERVICE=postgres\nDB_PORT=5432" >> "$file"

echo -e "\nDatabase configuration created succefully!"
\end{python}

Algumas \textit{tasks} foram adicionadas ao projeto, com auxílio da ferramenta Invoke\footnote{\url{http://www.pyinvoke.org/}}, para facilitarem na execução de comandos longos e serviços do SMI-UnB. Por exemplo, para criar um ambiente de produção do servidor mestre seria necessário seguir os seguintes passos:

\begin{itemize}
    \item Executar \textit{script} para variáveis de ambiente do banco de dados;
    \item Montar os contêiners do SMI-UnB;
    \item Iniciar os contêiners.
\end{itemize}

Ao invés de executar os comandos individualmente, esses são agrupados em uma \textit{task} chamada \textit{install\_master}, Algoritmo \ref{task_install_master}, responsável por executá-los sequêncialmente.

\begin{python}[caption={\textit{Task} \textit{install\_master}, presente no arquivo \textit{tasks.py}.}, captionpos=b, label={task_install_master}]
# Docker Tasks
@task
def install_master(ctx):
    print('Installing Master Docker')

    # Database configuration
    subprocess.call(['./scripts/db_initial_data.sh'])

    # Building docker containers
    run('docker-compose -f docker-compose-master.yml build
         --force-rm')

    # Initializing containers
    run('docker-compose -f docker-compose-master.yml up -d')
\end{python}

\subsection{Integração Contínua}
O script de integração contínua do projeto, Algoritmo \ref{integracao}, utiliza imagens oficiais do Python 3.5 e do Postgresql, presentes no Docker-Hub\footnote{\url{https://hub.docker.com/}}, que é repositório oficial de imagens do Docker. Todas as imagens do docker-hub já estão prontas para serem executadas em contêiners. Após os contêiners serem iniciados e vinculados, é realizada a instalação dos pacotes utilizados pelo SMI-UnB. Com a instalação dos pacotes, inicia-se verificação das normas da PEP8, com a ferramenta flake8 e por fim, são executados todos os testes do sistema e exibida a cobertura total, por meio da ferramenta Coverage\footnote{\url{https://pypi.python.org/pypi/coverage/}}.

\begin{python}[caption={\textit{Script} para integração contínua do projeto.}, captionpos=b, label={integracao}]
image: "python:3.5"

services:
  - postgres:latest

variables:
  POSTGRES_DB: smiunbtest
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: ""

test:
    script:
        - apt-get update -qq
        - apt-get install python3-pip -y -qq
        - pip3 install -e .[dev]
        - flake8 src/ --exclude migrations
        - coverage run manage.py test smi_unb \
          --settings=smi_unb.settings_runner
        - coverage report
\end{python}

\section{Apresentação das Informações}
O \textit{framework} Bootstrap foi utilizado como base para se realizar o \textit{layout} da aplicação, por possuir estruturas bem definidas e fáceis de serem utilizadas. Utilizou-se o jQuery\footnote{\url{https://jquery.com/}} para facilitar o uso de \textit{javascripts} na aplicação. Os ícones presentes foram provenientes do Font Awesome\footnote{\url{http://fontawesome.io/}}. Tanto o Boostrap quanto o Font Awesome são disponilizados sobre uma licença livre e podem ser utilizados em qualquer projeto, contanto que haja uma referêcia sobre eles.

Ressalta-se que não foi realizado nenhum teste de usabilidade para a aplicação. Os princípios de usabilidade utilizados partiram de conhecimentos do próprio autor, adquiridos através de conceitos da literatura e experiências pessoais.

A página inicial do SMI-UnB, Figura \ref{main_page}, utiliza uma imagem livre do site \textit{FreeImages}\footnote{\url{http://pt.freeimages.com}}, disponibilizada sob sua licença\footnote{\url{http://pt.freeimages.com/license}}. O \textit{site} e o criador, Friedrich Plechschmidt, possuem todos os direitos de propriedade intelectual sobre a imagem.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.35]{figuras/main_page.eps}
    \caption{Página inicial do SMI-UnB.}
    \label{main_page}
\end{figure}

Com o painel de controle, Figura \ref{dashboard}, é possível acessar os principais recursos do sistema de maneira fácil e intuitiva.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.35]{figuras/dashboard.eps}
    \caption{Página do painel de controle do SMI-UnB.}
    \label{dashboard}
\end{figure}

Os botões da aplicação, Figuras \ref{buttons} e \ref{buttons_2}, possuem cores e nomes significativos, para auxiliar os usuários realizarem as funções do sistema.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.4]{figuras/buttons.eps}
    \caption{Botões presentes na página de um campus.}
    \label{buttons}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.4]{figuras/buttons_2.eps}
    \caption{Botões presentes na página de um transdutor.}
    \label{buttons_2}
\end{figure}

As operações de criar, atualizar, habilitar ou desabilitar necessitam de uma confirmação, Figura \ref{block}, para que possam ser efetuadas. Ressalta-se que a apresentação da caixa de confirmação precisa ser aperfeiçoada.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.7]{figuras/block.eps}
    \caption{Confirmação necessária para se habilitar um prédio.}
    \label{block}
\end{figure}

As páginas do sistema possuem \textit{links} para páginas anteriores e informam a página presente, Figura \ref{links}, evitando que o usuário se perca na aplicação e possa facilmente voltar para onde quiser.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.7]{figuras/links.eps}
    \caption{\textit{Links} de todas as páginas até transdutor específico.}
    \label{links}
\end{figure}

As demais imagens do SMI-UnB encontram-se em Anexo.

\subsection{Gráfico de Linhas}
Realizou-se um gráfico de linhas com auxílio do app \textit{report}, Figura \ref{app_report}. A biblioteca utilizada para criar o gráfico foi a \textit{matplotlib} \footnote{\url{https://matplotlib.org/}}. Utilizou-se o \textit{plugin} \textit{mpld3}\footnote{\url{http://mpld3.github.io/}} para apresentação e dinamicidade do gráfico.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.6]{figuras/app_report.eps}
    \caption{Diagrama de Classes para \textit{App} \textit{report}.}
    \label{app_report}
\end{figure}

Foram definidas quatro importantes classes no \textit{app} \textit{report}, sendo estas:

\begin{itemize}
    \item \textit{GraphDateManager}: realiza o tratamento e manipulação de datas, utilizadas para indicar um determinado período de medição do gráfico;
    \item \textit{GraphPlotManager}: realiza a plotagem de todos os elementos do gráfico;
    \item \textit{GraphDataManager}: realiza cálculos com os valores que serão apresentados no gráfico;
    \item \textit{GraphUtils}: indica quais serão os tipos de medições apresentados no gráfico.
\end{itemize}

Definiu-se que o período máximo para apresentação de informações seria de 1 semana. Além disso, o máximo de pontos apresentados em um gráfico foi definido como 200, para que esse não demorasse muito a ser gerado. Para isso, definiu-se as seguintes médias:

\begin{itemize}
    \item Até 2 horas: gráfico com médias de 1 em 1 minuto;
    \item Entre 2 e 6 horas: gráfico com médias de 5 em 5 minutos;
    \item Entre 6 e 24 horas: gráfico com médias de 10 em 10 minutos;
    \item Entre 1 dia e 7 dias: gráfico com médias de 1 em 1 hora.
\end{itemize}

Para se gerar um gráfico basta selecionar um transdutor, o tipo de medição e uma opção para o período de coleta, Figura \ref{graph_options}

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true, scale=0.5]{figuras/graph_options.eps}
    \caption{Opções apresentadas para se gerar um gráfico de linhas.}
    \label{graph_options}
\end{figure}

A Figura \ref{graph_1} ilustra o gráfico de linhas com medições reais de tensão realizadas em um ambiente de teste no campus UnB-Gama, refentes ao dia 25/06/2017.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.5]{figuras/graph_1.eps}
    \caption{Medições de tensão realizadas em ambiente de testes, referentes ao dia 25/06/2017.}
    \label{graph_1}
\end{figure}

Outro exemplo, Figura \ref{graph_2}, ilustra o gráfico de linhas gerado com medições de corrente, referentes ao dia 19/06/2017. Percebe-se nesse gráfico que houve períodos sem medições, representados pelos retângulos amarelos. Outro ponto importante a se destacar refere-se à capacidade da aplicação de continuar realizando a coleta de dados do transdutor, mesmo possuindo períodos sem realizar efetivamente uma medição.

\begin{figure}[!h]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.5]{figuras/graph_2.eps}
    \caption{Medições de corrente realizadas em ambiente de testes, referentes ao dia 19/06/2017.}
    \label{graph_2}
\end{figure}

\section{Métricas}
Codeclimate

sloccount

\section{Requisitos Mínimos}
    Rodar linux

    Rede?