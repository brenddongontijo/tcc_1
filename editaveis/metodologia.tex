\chapter{Métodos Empíricos em Engenharia de \textit{Software}}

\section{Requisitos de \textit{Software}}
    Os negócios atualmente operam em um ambiente global sujeito a rápidas mudanças sendo crucial
    estar preparado para novas oportunidades de mercado, mudanças de condições econômicas e ao surgimento
    de produtos e serviços concorrentes. O \textit{software} é um dos componentes cruciais para a realização
    de várias operações de negócio e realizá-lo de forma rápida também é uma maneira de aproveitar novas
    oportunidades e responder às pressões competitivas \cite{sommerville_2006}.

    Entender os requisitos de um problema é uma das difíceis missões
    que são encaradas na Engenharia de \textit{Software}. Em muitos casos, o cliente não sabe o que realmente quer ou até mesmo
    suas acaba mudando suas necessidades com o decorrer do projeto.   Sommerville \cite{sommerville_2006} define os requisitos de um projeto como ``requisitos do usuário'' e ``requisitos do sistema''. Os requisitos de usuários consistem de declarações, em
    linguagem natural, que o sistema deve fornecer e restrições que o mesmo deve
    operar. Os requisitos de sistema estabelecem de maneira detalhada as
    funções e restrições do sistema. Além disso, os requisitos de sistema
    classificam-se em funcionais e não funcionais:

    \begin{itemize}
        \item Requisitos Funcionais: declaração de funções que o sistema deve fornecer, como o mesmo irá reagir com certas entradas e como deve se comportar para certas situaçoes.
        \item Requisitos Não Funcionais: restrições sobre serviços ou funções oferecidas pelo sistema.
    \end{itemize}

    O levantamento adequado de requisitos de \textit{software} é crucial para que possa ser feito um mapeamento das reais necessidades do cliente com funcionalidades que um sistema deve atender. Para Sommerville \cite{sommerville_2006}, após de ser realizado um estudo de viabilidade do problema que será enfrentado, realiza-se a atividade de elicitação de requisitos. Na elicitação de requisitos os engenheiros de \textit{software} trabalham com os clientes e usuários finais do sistema para aprender sobre o domínio da aplicação, os serviços que serão necessários, desempenho esperado, restrições de \textit{hardware} etc. Thayer \cite{thayer_1997} define a Engenharia de Requisitos como um processo que provê os mecanismos apropriados para o entendimento do que o cliente quer, analisando a necessidade, avaliando a viabilidade, negociando uma solução inteligente, especificando a solução de maneira não ambígua, validando a especificação e gerenciando os requisitos conforme os mesmos são transformados em um sistema operacional.

    Dentre as atividades da Engenharia de Requisitos encontra-se a elicitação de requisitos, a qual, para Leite \cite{leite_1994}, é reponsável por identificar todos os fatos que irão fazer parte dos requisitos do sistema, buscando fornecer todo o entendimento que o \textit{software} deve possuir. Uma das técnicas comumente utilizadas para a elicitação de requisitos é a entrevista com questionários \cite{goguen_1994}.

    CASO DE USO E USER STORY

\section{Métodos Ágeis}
O manifesto ágil \cite{beck2001agile} consiste na base que fundamenta o desenvolvimento ágil de
\textit{software} sendo composto de quatro valores fundamentais:

\begin{itemize}
    \item \textbf{Os indivíduos e suas interações} acima de procedimentos e ferramentas;
    \item \textbf{O funcionamento do \textit{software}} acima de documentação abrangente;
    \item \textbf{A colaboração dos clientes} acima da negociação de contratos;
    \item \textbf{A capacidade de resposta a mudanças} acima de um plano pré-estabelecido.
\end{itemize}

\textit{``Enquanto há valor nos itens à direita, valorizamos mais os itens à esquerda''} \cite{beck2001agile}.

Além desses valores são definidos 12 princípios de agilidade:

\begin{itemize}
    \item Nossa maior prioridade é satisfazer o cliente, através da entrega adiantada e contínua de \textit{software} de valor;
    \item Aceitar mudanças de requisitos, mesmo no fim do desenvolvimento. Processos ágeis se adequam a mudanças, para que o cliente possa tirar vantagens competitivas;
    \item Entregar \textit{software} funcionando com freqüencia, na escala de semanas até meses, com preferência aos períodos mais curtos;
    \item Pessoas relacionadas a negócios e desenvolvedores devem trabalhar em conjunto e diariamente, durante todo o curso do projeto;
    \item Construir projetos ao redor de indivíduos motivados. Dando a eles o ambiente e suporte necessário, e confiar que farão seu trabalho;
    \item O Método mais eficiente e eficaz de transmitir informações para, e por dentro de um time de desenvolvimento, é através de uma conversa cara a cara;
    \item \textit{Software} funcional é a medida primária de progresso;
    \item Processos ágeis promovem um ambiente sustentável. Os patrocinadores, desenvolvedores e usuários, devem ser capazes de manter indefinidamente, passos constantes;
    \item Contínua atenção à excelência técnica e bom design, aumenta a agilidade;
    \item Simplicidade: a arte de maximizar a quantidade de trabalho que não precisou ser feito;
    \item As melhores arquiteturas, requisitos e designs emergem de times auto-organizáveis;
    \item Em intervalos regulares, o time reflete em como ficar mais efetivo, então, se ajustam e otimizam seu comportamento de acordo.
\end{itemize}

Nem todos os processos ágeis aplicam tais princípios de maneira igualitária e alguns modelos escolhem ignorar (ou ao menos minimizar) a importância de um ou mais princípios \cite{pressman_2009}.

Processos de desenvolvimento ágeis geralmente são iterativos onde a
especificação, projeto, desenvolvimento e teste são intercalados. O \textit{software} é desenvolvido
em uma série de incrementos e cada incremento fornece uma nova funcionalidade ao sistema \cite{sommerville_2006}. As duas principais
vantagens de se adotar uma abordagem incremental para o desenvolvimento de \textit{software} são:

\begin{itemize}
    \item Entrega acelerada dos serviços ao cliente. Os clientes poderão obter valor do sistema já nos incrementos iniciais;
    \item Engajamento do usuário com o sistema. Os usuários do sistema devem estar envolvidos no processo
    de desenvolvimento dando \textit{feedback} à equipe de desenvolvimento sobre os incrementos entregues.
\end{itemize}

    \subsection{\textit{Extreme Programming}}
    \textit{Extreme Programming} (XP) é uma filosofia de desenvolvimento de \textit{software} baseada nos valores de comunicação, simplicidade, \textit{feedback} e coragem. É designado para se trabalhar com projetos que podem ser
    construídos por equipes de dois a dez programadores, os quais não devem possuir limitações
    por causa do ambiente computacional e possam ser capazes de realizar testes de
    \textit{software} em uma fração de um dia \cite{beck_2004}.

    No XP, são definidas 12 importantes práticas que auxiliam no
    desenvolvimento de \textit{software} e em suas \textit{releases}.
    Uma \textit{release} consiste no lançamento, parcial ou não,
    de um \textit{software}, sendo que em muitas das vezes são
    lançadas versões beta do mesmo, proporcionando, assim, uma possível
    fase de \textit{debugging} ou \textit{feedback}, provinda do
    cliente ou até mesmo da equipe de desenvolvimento. As práticas do XP, por sua vez, alinham-se bem no decorrer do ciclo de desenvolvimento de \textit{software} e são includentes, ou seja, onde uma possui determinada desvantagem, outra
    irá compensar com seus pontos positivos \cite{beck_2004}. As práticas são:

    \begin{itemize}
        \item Cliente Presente: clientes devem sempre estar presentes para auxiliarem a equipe com seus \textit{feedbacks}.
        \item \textit{Design} Simples: o sistema deve sempre ser desenhado de forma o mais simples possível, sendo que complexidades encontradas devem ser removidas rapidamente.
        \item Integração Contínua: integração e construção do sistema muitas vezes ao dia, sempre que uma tarefa
        for concluída.
        \item Jogo do Planejamento (do inglês \textit{Planning Game}): determina de maneira rápida o escopo de uma \textit{release} combinando prioridades de negócio e estimativas técnicas.
        \item Metáfora (do inglês \textit{Metaphor}): linguagem comum que os membros devem possuir para poderem explicar facilmente como o sistema funciona como um todo.
        \item Padrões de Codificação: escrita do código de acordo com boas práticas de programação, enfatizando uma comunicação através do mesmo.
        \item Programação em Pares: realizar a codificação do sistema sempre
        com dois programadores que compartilham a mesma máquina.
        \item Propriedade Coletiva: qualquer pessoa pode modificar, desde que esteja realizando de maneira correta, qualquer parte do código a qualquer momento.
        \item Refatoração: reestruturação do sistema sem alteração de seu comportamento, objetivando
        remover duplicidade, simplificação de código, aumento de flexibilidade e melhoramento da comunicação.
        \item Semana de 40 horas: o trabalho semanal realizado não pode ultrapassar o limite de 40 horas.
        \item Teste: são escritos testes unitários, que devem funcionar de maneira adequada para que
        o desenvolvimento do sistema continue.
        \item Versões Pequenas: colocar rapidamente um sistema simples e funcional em produção, para que posteriormente sejam lançadas novas versões do mesmo em um curto período de tempo.
    \end{itemize}

    USER STORY

    No caso do XP, são utilizadas estórias de usuários, ou semelhantes, como pontapé inicial para que possa ser iniciado o processo de coleta e desenvolvimento de um \textit{software}

    \subsection{Teste de \textit{Software}}
    Teste de \textit{software} é o processo de execução de um produto para averiguar se ele atingiu suas especificações e funciona corretamente em seu ambiente alvo \cite{artigo_intro_teste}.

    De acordo com \citeonline{sw_test_tech}, um bom teste é o que possui uma alta probabilidade de encontrar um erro ainda não descoberto e um teste bem sucedido é o que de fato descobre erros desconhecidos.

    Esses testes são estruturados em níveis, cada um com um determinado objetivo dentro do conjunto de testes, de modo a garantir a qualidade do produto em desenvolvimento \cite{sw_test_tech}.

        \subsubsection{Testes Unitários}
        Testes unitários possuem como objetivo verificar a existência de defeitos em cada módulo do projeto. Seu alvo são os métodos desenvolvidos ou pequenos trechos específicos de código \cite{artigo_intro_teste}.

        É realizado durante o desenvolvimento, pelo próprio desenvolvedor, pois testa a unidade básica de \textit{software}, que é o menor ``pedaço''  testável, por sua vez chamado de unidade, dando origem ao nome deste tipo de teste \cite{sw_test_tech}.

        Um exemplo de objetivo do teste unitário é a procura pela identificação de erros de lógica e de implementação \cite{maldonado}.

\section{Gerência de Configuração de \textit{Software}}
Um sistema pode ser definido como a combinação de elementos que entre si interagem e estão organizados para alcançar um ou mais objetivos previamente declarados, onde suas características físicas e funcionais de \textit{hardware} ou software representam sua configuração \cite{SWEBOK2014}.

Em uma definição mais formal, a ISO 24765 \cite{iso_24765} define Gerência de Configuração como uma disciplina responsável por: ``identificar e documentar as características funcionais e físicas de um item de configuração, controlar as alterações dessas características, registar e reportar o processamento de alterações e o \textit{status} de implementação, e verificar a conformidade com os requisitos especificados''.

A Gerência de Configuração de Software (SCM, do inglês \textit{Software Configuration Management}) é um processo que beneficia o gerenciamento de projeto, assim como o seu desenvolvimento, manutenção e atividades referentes à garantia de qualidade \cite{SWEBOK2014}.

O CMMI-DEV \cite{cmmi_dev} define 3 objetivos para a Gerência de Configuração de Software:
\begin{itemize}
    \item Estabelecimento de \textit{Baselines}: para cada nova mudança implementada um incremento na evolução do projeto é gerado. Essas mudanças devem possuir um histórico bem definido. As ferramentas de controle de versão facilitam esse trabalho, além de possibilitarem uma programação concorrente.
    \item Rastreamento e Controle de Mudanças: durante o desenvolvimento de software mudanças ocorrem com frequência. É necessário portanto que as mesmas sejam armazenadas, analisadas e agrupadas de acordo com o histórico e suas prioridades.
    \item Estabelecimento de Integridade: verificar se a construção de um sistema, atendendo suas configurações pré-estabelecidas, é bem sucedida a cada nova mudança registrada.
\end{itemize}

\section{\textit{Software} Livre}
``O Software livre é aquele que permite aos usuários usá-lo, estudá-lo, modificá-lo e redistribui-lo, em geral, sem restrições para tal e prevenindo que não sejam impostas restrições aos futuros usuários'' \cite{meirelles2013}.

Em comparação ao software restrito, o software livre apresenta algumas vantagens devido ao fato de seu código-fonte estar disponível para qualquer usuário, partindo do princípio que seu licenciamento esteja de acordo com as definições da \textit{Free Software Foundation}\footnote{\url{http://www.gnu.org/philosophy/free-sw.pt-br.html}} ou da \textit{Open Source Initiative}\footnote{\url{https://opensource.org/docs/definition.html}}. Essa disponibilidade auxilia no desenvolvimento de aplicações personalizadas, uma vez que que é possível partir de uma solução já existente ao invés de desenvolver tudo partindo do zero. Tal abordagem possui um impacto significativo na redução de custos e diminuição na duplicação de esforço \cite{meirelles2013}.

Raymond \cite{raymond1999}, observando o modelo de desenvolvimento do Linux, percebeu que o compartilhamento de código possivelmente melhoraria a qualidade final de uma aplicação, uma vez que uma quantidade grande de desenvolvedores, com diferentes habilidades e conhecimentos, conseguem propor melhorias e consertar \textit{bugs} em uma pequena quantidade de tempo \cite{meirelles2013}.

\section{Usabilidade de \textit{Software}}
A usabilidade é geralmente considerada como o fator que assegura que
os produtos sejam fáceis de usar, eficientes e agradáveis, sob a
perspectiva do usuário, através da otimização das interações
estabelecidas pelas pessoas com produtos interativos \cite{rogers_2013}.

Segundo a ISO 9126 \cite{iso9126}, o conceito de usabilidade, em um contexto de software, é definido como "capacidade do produto de software de ser entendido, aprendido, usado e atraente para o usuário, quando usado em condições especificadas". Nielsen \cite{nielsen_1994} propõe que a usabilidade está distribuida em diversos elementos e define alguns fatores que estão associados a mesma, sendo esses:

\begin{itemize}
    \item Eficiência: proporcionar ao usuário o cumprimento do seu objetivo de forma rápida e fácil. Para isso, uma aplicação deve ser feita de forma simples, com o mínimo de poluição visual possível, intuitiva e bem estruturada, reduzindo o esforço e a dificuldade em se realizar um determinada tarefa.
    \item Facilidade de Aprendizagem: capacidade do cliente aprender rapidamente utilizar o sistema de maneira intuitiva.
    \item Facilidade de Memorização: o sistema deve ser capaz de ser facilmente memorizado, ou seja, por mais que um usuário fique um tempo sem utilizá-lo, o mesmo irá se recordar facilmente de como se usa.
    \item Satisfação: a utilização do sistema deve providenciar ao usuário uma experiência agradável.
    \item Seguraça: refere-se a prevenção para que o usuário não cometa erros. Uma aplicação deve conter botões de desfazer, botões de edição, pedidos de confirmação de ação antes da mesma ser realizada e dicas de como proceder em determinadas situações.
\end{itemize}

\section{Métricas de \textit{Software}}
